bus/config.h:struct TTcpBusServerConfig
bus/config.h:    explicit TTcpBusServerConfig(int port = -1)
bus/public.h:struct IBusServer;
bus/public.h:typedef TIntrusivePtr<IBusServer> IBusServerPtr;
bus/public.h:struct TTcpBusServerConfig;
bus/public.h:typedef TIntrusivePtr<TTcpBusServerConfig> TTcpBusServerConfigPtr;
bus/server.h:struct IBusServer
bus/tcp_connection.cpp:        case EConnectionType::Server:
bus/tcp_connection.cpp:        case EConnectionType::Server:
bus/tcp_connection.cpp:        case EConnectionType::Server: {
bus/tcp_connection.cpp:            int value = (Statistics().ServerConnectionCount += delta);
bus/tcp_connection.h:    (Server)
bus/tcp_dispatcher.cpp:    , ServerConnectionCount(0)
bus/tcp_dispatcher.h:    int ServerConnectionCount;
bus/tcp_dispatcher.h:    friend class TBusServerBase;
bus/tcp_dispatcher.h:    template <class TServer>
bus/tcp_dispatcher.h:    friend class TTcpBusServerProxy;
bus/tcp_server.cpp:class TBusServerBase
bus/tcp_server.cpp:    TBusServerBase(
bus/tcp_server.cpp:        TTcpBusServerConfigPtr config,
bus/tcp_server.cpp:        , ServerSocket(INVALID_SOCKET)
bus/tcp_server.cpp:        , ServerFd(INVALID_SOCKET)
bus/tcp_server.cpp:        OpenServerSocket();
bus/tcp_server.cpp:        AcceptWatcher->set<TBusServerBase, &TBusServerBase::OnAccept>(this);
bus/tcp_server.cpp:        AcceptWatcher->start(ServerFd, ev::READ);
bus/tcp_server.cpp:        CloseServerSocket();
bus/tcp_server.cpp:    TTcpBusServerConfigPtr Config;
bus/tcp_server.cpp:    int ServerSocket;
bus/tcp_server.cpp:    int ServerFd;
bus/tcp_server.cpp:    virtual void CreateServerSocket() = 0;
bus/tcp_server.cpp:    void OpenServerSocket()
bus/tcp_server.cpp:        CreateServerSocket();
bus/tcp_server.cpp:        InitSocket(ServerSocket);
bus/tcp_server.cpp:        if (listen(ServerSocket, SOMAXCONN) == SOCKET_ERROR) {
bus/tcp_server.cpp:            CloseServerSocket();
bus/tcp_server.cpp:        LOG_DEBUG("Server socket opened");
bus/tcp_server.cpp:    void CloseServerSocket()
bus/tcp_server.cpp:        if (ServerFd != INVALID_SOCKET) {
bus/tcp_server.cpp:            close(ServerFd);
bus/tcp_server.cpp:            LOG_DEBUG("Server socket closed");
bus/tcp_server.cpp:        ServerSocket = INVALID_SOCKET;
bus/tcp_server.cpp:        ServerFd = INVALID_SOCKET;
bus/tcp_server.cpp:                clientSocket = accept(ServerSocket, clientAddress.GetSockAddr(), &clientAddressLen);
bus/tcp_server.cpp:                EConnectionType::Server,
bus/tcp_server.cpp:                &TBusServerBase::OnConnectionTerminated,
bus/tcp_server.cpp:class TTcpBusServer
bus/tcp_server.cpp:    : public TBusServerBase
bus/tcp_server.cpp:    TTcpBusServer(
bus/tcp_server.cpp:        TTcpBusServerConfigPtr config,
bus/tcp_server.cpp:        : TBusServerBase(config, handler)
bus/tcp_server.cpp:    virtual void CreateServerSocket() override
bus/tcp_server.cpp:        ServerSocket = socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP);
bus/tcp_server.cpp:        if (ServerSocket == INVALID_SOCKET) {
bus/tcp_server.cpp:        ServerFd = _open_osfhandle(ServerSocket, 0);
bus/tcp_server.cpp:        ServerFd = ServerSocket;
bus/tcp_server.cpp:            setsockopt(ServerSocket, IPPROTO_IPV6, IPV6_V6ONLY, (const char*) &flag, sizeof(flag));
bus/tcp_server.cpp:            setsockopt(ServerSocket, SOL_SOCKET, SO_REUSEADDR, (const char*) &flag, sizeof(flag));
bus/tcp_server.cpp:            if (bind(ServerSocket, (sockaddr*)&serverAddress, sizeof(serverAddress)) != 0) {
bus/tcp_server.cpp:                CloseServerSocket();
bus/tcp_server.cpp:        TBusServerBase::InitClientSocket(clientSocket);
bus/tcp_server.cpp:class TLocalBusServer
bus/tcp_server.cpp:    : public TBusServerBase
bus/tcp_server.cpp:    TLocalBusServer(
bus/tcp_server.cpp:        TTcpBusServerConfigPtr config,
bus/tcp_server.cpp:        : TBusServerBase(config, handler)
bus/tcp_server.cpp:    virtual void CreateServerSocket() override
bus/tcp_server.cpp:    	ServerSocket = socket(AF_UNIX, SOCK_STREAM, 0);
bus/tcp_server.cpp:        if (ServerSocket == INVALID_SOCKET) {
bus/tcp_server.cpp:        ServerFd = ServerSocket;
bus/tcp_server.cpp:            if (bind(ServerSocket, netAddress.GetSockAddr(), netAddress.GetLength()) != 0) {
bus/tcp_server.cpp:                CloseServerSocket();
bus/tcp_server.cpp://! A lightweight proxy controlling the lifetime of #TTcpBusServer.
bus/tcp_server.cpp:template <class TServer>
bus/tcp_server.cpp:class TTcpBusServerProxy
bus/tcp_server.cpp:    : public IBusServer
bus/tcp_server.cpp:    explicit TTcpBusServerProxy(TTcpBusServerConfigPtr config)
bus/tcp_server.cpp:    ~TTcpBusServerProxy()
bus/tcp_server.cpp:        auto server = New<TServer>(Config, handler);
bus/tcp_server.cpp:        Server = server;
bus/tcp_server.cpp:        auto error = TTcpDispatcher::TImpl::Get()->AsyncUnregister(Server).Get();
bus/tcp_server.cpp:        Server.Reset();
bus/tcp_server.cpp:    TTcpBusServerConfigPtr Config;
bus/tcp_server.cpp:    TIntrusivePtr<TServer> Server;
bus/tcp_server.cpp:class TCompositeBusServer
bus/tcp_server.cpp:    : public IBusServer
bus/tcp_server.cpp:    explicit TCompositeBusServer(const std::vector<IBusServerPtr>& servers)
bus/tcp_server.cpp:        : Servers(servers)
bus/tcp_server.cpp:        FOREACH (auto server, Servers) {
bus/tcp_server.cpp:        FOREACH (auto server, Servers) {
bus/tcp_server.cpp:    std::vector<IBusServerPtr> Servers;
bus/tcp_server.cpp:IBusServerPtr CreateTcpBusServer(TTcpBusServerConfigPtr config)
bus/tcp_server.cpp:    std::vector<IBusServerPtr> servers;
bus/tcp_server.cpp:    servers.push_back(New< TTcpBusServerProxy<TTcpBusServer> >(config));
bus/tcp_server.cpp:    servers.push_back(New< TTcpBusServerProxy<TLocalBusServer> >(config));
bus/tcp_server.cpp:    return New<TCompositeBusServer>(servers);
bus/tcp_server.h:IBusServerPtr CreateTcpBusServer(TTcpBusServerConfigPtr config);
meta_state/persistent_state_manager.cpp:        NRpc::IServerPtr server)
meta_state/persistent_state_manager.cpp:    NRpc::IServerPtr server)
meta_state/persistent_state_manager.h:    NRpc::IServerPtr server);
monitoring/http_integration.cpp:        return FormatInternalServerErrorResponse(rsp->GetError().GetMessage().Quote());
monitoring/http_integration.cpp:        return MakeFuture(FormatInternalServerErrorResponse(Stroka(ex.what()).Quote()));
monitoring/http_integration.cpp:TServer::TAsyncHandler GetYPathHttpHandler(IYPathServicePtr service)
monitoring/http_integration.cpp:TServer::TAsyncHandler GetYPathHttpHandler(TYPathServiceProducer producer)
monitoring/http_integration.h:NHttp::TServer::TAsyncHandler GetYPathHttpHandler(
monitoring/http_integration.h:NHttp::TServer::TAsyncHandler GetYPathHttpHandler(
monitoring/http_server.cpp:class TServer::TImpl
monitoring/http_server.cpp:void TServer::TImpl::Run() const
monitoring/http_server.cpp:    TNLHttpServer httpServer(Port);
monitoring/http_server.cpp:        SOCKET clientSocket = httpServer.Accept(&httpRequest, InputConnectionWaitTime);
monitoring/http_server.cpp:bool TServer::TImpl::HandlePendingRequest(TPendingRequest& request) const
monitoring/http_server.cpp:bool TServer::TImpl::HandleNewRequest(TPendingRequest& request) const
monitoring/http_server.cpp:void TServer::TImpl::Start()
monitoring/http_server.cpp:void TServer::TImpl::Stop()
monitoring/http_server.cpp:void TServer::TImpl::SendResponse(const TPendingRequest& request, const Stroka& result) const
monitoring/http_server.cpp:void* TServer::TImpl::ThreadFunc(void* param)
monitoring/http_server.cpp:    auto* impl = (TServer::TImpl*) param;
monitoring/http_server.cpp:class TServer::TImpl
monitoring/http_server.cpp:        : public THttpServer::ICallBack
monitoring/http_server.cpp:    THolder<THttpServer> Server;
monitoring/http_server.cpp:        Server.Reset(new THttpServer(~Callback,
monitoring/http_server.cpp:            THttpServerOptions(static_cast<ui16>(port))
monitoring/http_server.cpp:        Server->Start();
monitoring/http_server.cpp:        Server->Stop();
monitoring/http_server.cpp:Stroka FormatInternalServerErrorResponse(const Stroka& body)
monitoring/http_server.cpp:        "HTTP/1.1 500 Internal Server Error\r\n"
monitoring/http_server.cpp:        "Server: YT\r\n"
monitoring/http_server.cpp:TServer::TServer(int port)
monitoring/http_server.cpp:TServer::~TServer()
monitoring/http_server.cpp:void TServer::Register(const Stroka& prefix, TSyncHandler handler)
monitoring/http_server.cpp:void TServer::Register(const Stroka& prefix, TAsyncHandler handler)
monitoring/http_server.cpp:void TServer::Start()
monitoring/http_server.cpp:void TServer::Stop()
monitoring/http_server.h://! Formats a canonical "Internal Server Error" (500) response.
monitoring/http_server.h:Stroka FormatInternalServerErrorResponse(const Stroka& body = "");
monitoring/http_server.h:class TServer
monitoring/http_server.h:    TServer(int port);
monitoring/http_server.h:    ~TServer();
object_client/object_service_proxy-inl.h:} // namespace NObjectServer
rpc/private.cpp:NLog::TLogger RpcServerLogger("RpcServer");
rpc/private.cpp:NProfiling::TProfiler RpcServerProfiler("/rpc/server");
rpc/private.h:extern NLog::TLogger RpcServerLogger;
rpc/private.h:extern NProfiling::TProfiler RpcServerProfiler;
rpc/public.h:struct IServer;
rpc/public.h:typedef TIntrusivePtr<IServer> IServerPtr;
rpc/redirector_service.cpp:static NLog::TLogger& Logger = RpcServerLogger;
rpc/server.cpp:static NLog::TLogger& Logger = RpcServerLogger;
rpc/server.cpp:class TRpcServer
rpc/server.cpp:    : public IServer
rpc/server.cpp:    TRpcServer(IBusServerPtr busServer)
rpc/server.cpp:        : BusServer(busServer)
rpc/server.cpp:        BusServer->Start(this);
rpc/server.cpp:        BusServer->Stop();
rpc/server.cpp:        BusServer.Reset();
rpc/server.cpp:    IBusServerPtr BusServer;
rpc/server.cpp:            Stroka message = Sprintf("Server is not started (RequestId: %s)",
rpc/server.cpp:IServerPtr CreateRpcServer(NBus::IBusServerPtr busServer)
rpc/server.cpp:    return New<TRpcServer>(busServer);
rpc/server.h:struct IServer
rpc/server.h:IServerPtr CreateRpcServer(NBus::IBusServerPtr busServer);
rpc/service.cpp:static NLog::TLogger& Logger = RpcServerLogger;
rpc/service.cpp:static NProfiling::TProfiler& Profiler = RpcServerProfiler;
rpc/service.h:extern NLog::TLogger RpcServerLogger;
rpc/service.h:        : Logger(RpcServerLogger)
rpc/service.h:extern NLog::TLogger RpcServerLogger;
table_client/chunk_writer_base.cpp:using namespace NChunkServer;
