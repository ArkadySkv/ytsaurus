$$ Please, use Pump to convert this source file to valid C++ header.
$$ Note that lines in this file could be longer than 80 symbols.
$var n = 5 $$ The maximum arity.
// vim:set ft=cpp:
#pragma once

/*! \internal */

#ifndef ACTION_UTIL_GEN_H_
#error "Direct inclusion of this file is not allowed, include action_util.h"
#endif
#undef ACTION_UTIL_GEN_H_

namespace NYT {

////////////////////////////////////////////////////////////////////////////////

[[]]
$$ Here comes the boilerplate part with 2^3 = 8 flavours.
$$  - Member/Free function
$$  - With/Without parameter
$$  - With/Without return value
$range i 0..n
$for i [[
$range j 1..i
////////////////////////////////////////////////////////////////////////////////
// $i-arity
////////////////////////////////////////////////////////////////////////////////

$var tmpl_args = [[$for j, [[class TArg$j]]]]
$var ctor_args = [[$for j [[, const TArgCopy$j& arg$j]]]]
$var ctor_list = [[$for j [[, Arg$j(arg$j)]]]]
$var wrap_args = [[$for j [[,
    const typename TActionArgTraits<TArg$j>::TCopy& arg$j]]
]]

$$ Handy shortcuts.
$var _and_ = [[$if i == 0 [[]] $else [[, ]]]]
$var TArgs = [[$for j, [[TArg$j]]]]
$var  Args = [[$for j, [[Arg$j]]]]
$var  args = [[$for j, [[arg$j]]]]

////////////////////////////////////////////////////////////////////////////////
// Thunk for member function, without parameter, without return value.
namespace NActionThunks {
template <class TTargetPtr$_and_$tmpl_args>
class TMemberVoidFunc$i
    : public IAction
{
private:
    typedef typename TActionTargetTraits<TTargetPtr>::TUnderlying TUnderlying;
    typedef void (TUnderlying::* TMethod)($TArgs);

$for j [[
    typedef typename TActionArgTraits<TArg$j>::TCopy TArgCopy$j;

]]

    TTargetPtr Target;
    TMethod Method;

$for j [[
    TArgCopy$j Arg$j;

]]

public:
    TMemberVoidFunc$i(TTargetPtr target, TMethod method$ctor_args)
        : Target(target), Method(method)$ctor_list
    { }

    virtual void Do()
    {
        typedef TActionTargetTraits<TTargetPtr> TTraits;

        auto lock = TTraits::Lock(Target);
        TUnderlying* target = TTraits::Get(Target);

        if (TTraits::StrongReference || target) {
            (target->*Method)($Args);
        }
    }
};
} // namespace NActionThunks

// Corresponding wrapper.
template <class TTargetPtr, class TUnderlying$_and_$tmpl_args>
inline // TODO: FORCED_INLINE
IAction::TPtr FromMethod(
    void (TUnderlying::* method)($TArgs),
    TTargetPtr target$wrap_args)
{
    return New< NActionThunks::TMemberVoidFunc$i<TTargetPtr$_and_$TArgs> >(target, method$_and_$args);
}

////////////////////////////////////////////////////////////////////////////////
// Thunk for const member function, without parameter, without return value.
namespace NActionThunks {
template <class TTargetPtr$_and_$tmpl_args>
class TConstMemberVoidFunc$i
    : public IAction
{
private:
    typedef typename TActionTargetTraits<TTargetPtr>::TUnderlying TUnderlying;
    typedef void (TUnderlying::* TMethod)($TArgs) const;

$for j [[
    typedef typename TActionArgTraits<TArg$j>::TCopy TArgCopy$j;

]]

    TTargetPtr Target;
    TMethod Method;

$for j [[
    TArgCopy$j Arg$j;

]]

public:
    TConstMemberVoidFunc$i(const TTargetPtr target, TMethod method$ctor_args)
        : Target(target), Method(method)$ctor_list
    { }

    virtual void Do()
    {
        typedef TActionTargetTraits<TTargetPtr> TTraits;

        auto lock = TTraits::Lock(Target);
        TUnderlying* target = TTraits::Get(Target);

        if (TTraits::StrongReference || target) {
            (target->*Method)($Args);
        }
    }
};
} // namespace NActionThunks

// Corresponding wrapper.
template <class TTargetPtr, class TUnderlying$_and_$tmpl_args>
inline // TODO: FORCED_INLINE
IAction::TPtr FromMethod(
    void (TUnderlying::* method)($TArgs) const,
    const TTargetPtr target$wrap_args)
{
    return New< NActionThunks::TConstMemberVoidFunc$i<TTargetPtr$_and_$TArgs> >(target, method$_and_$args);
}

////////////////////////////////////////////////////////////////////////////////
// Thunk for member function, without parameter, with return value.
namespace NActionThunks {
template <class TResult, class TTargetPtr$_and_$tmpl_args>
class TMemberFunc$i
    : public IFunc<TResult>
{
private:
    typedef typename TActionTargetTraits<TTargetPtr>::TUnderlying TUnderlying;
    typedef TResult (TUnderlying::* TMethod)($TArgs);

$for j [[
    typedef typename TActionArgTraits<TArg$j>::TCopy TArgCopy$j;

]]

    TTargetPtr Target;
    TMethod Method;

$for j [[
    TArgCopy$j Arg$j;

]]

public:
    TMemberFunc$i(TTargetPtr target, TMethod method$ctor_args)
        : Target(target), Method(method)$ctor_list
    { }

    virtual TResult Do()
    {
        TUnderlying* target = TActionTargetTraits<TTargetPtr>::Get(Target);
        return (target->*Method)($Args);
    }
};
} // namespace NActionThunks

// Corresponding wrapper.
template <class TResult, class TTargetPtr, class TUnderlying$_and_$tmpl_args>
inline // TODO: FORCED_INLINE
typename IFunc<TResult>::TPtr FromMethod(
    TResult (TUnderlying::* method)($TArgs),
    TTargetPtr target$wrap_args)
{
    return New< NActionThunks::TMemberFunc$i<TResult, TTargetPtr$_and_$TArgs> >(target, method$_and_$args);
}

////////////////////////////////////////////////////////////////////////////////
// Thunk for member function, with parameter, without return value.
namespace NActionThunks {
template <class TParam, class TTargetPtr$_and_$tmpl_args>
class TParamMemberVoidFunc$i
    : public IParamAction<TParam>
{
private:
    typedef typename TActionTargetTraits<TTargetPtr>::TUnderlying TUnderlying;
    typedef void (TUnderlying::* TMethod)(TParam$_and_$TArgs);

$for j [[
    typedef typename TActionArgTraits<TArg$j>::TCopy TArgCopy$j;

]]

    TTargetPtr Target;
    TMethod Method;

$for j [[
    TArgCopy$j Arg$j;

]]

public:
    TParamMemberVoidFunc$i(TTargetPtr target, TMethod method$ctor_args)
        : Target(target), Method(method)$ctor_list
    { }

    virtual void Do(TParam param)
    {
        typedef TActionTargetTraits<TTargetPtr> TTraits;

        auto lock = TTraits::Lock(Target);
        TUnderlying* target = TTraits::Get(Target);

        if (TTraits::StrongReference || target) {
            (target->*Method)(param$_and_$Args);
        }
    }
};
} // namespace NActionThunks

// Corresponding wrapper.
template <class TParam, class TTargetPtr, class TUnderlying$_and_$tmpl_args>
inline // TODO: FORCED_INLINE
typename IParamAction<TParam>::TPtr FromMethod(
    void (TUnderlying::* method)(TParam$_and_$TArgs),
    TTargetPtr target$wrap_args)
{
    return New< NActionThunks::TParamMemberVoidFunc$i<TParam, TTargetPtr$_and_$TArgs> >(target, method$_and_$args);
}

////////////////////////////////////////////////////////////////////////////////
// Thunk for const member function, with parameter, without return value.
namespace NActionThunks {
template <class TParam, class TTargetPtr$_and_$tmpl_args>
class TParamConstMemberVoidFunc$i
    : public IParamAction<TParam>
{
private:
    typedef typename TActionTargetTraits<TTargetPtr>::TUnderlying TUnderlying;
    typedef void (TUnderlying::* TMethod)(TParam$_and_$TArgs) const;

$for j [[
    typedef typename TActionArgTraits<TArg$j>::TCopy TArgCopy$j;

]]

    TTargetPtr Target;
    TMethod Method;

$for j [[
    TArgCopy$j Arg$j;

]]

public:
    TParamConstMemberVoidFunc$i(const TTargetPtr target, TMethod method$ctor_args)
        : Target(target), Method(method)$ctor_list
    { }

    virtual void Do(TParam param)
    {
        typedef TActionTargetTraits<TTargetPtr> TTraits;

        auto lock = TTraits::Lock(Target);
        TUnderlying* target = TTraits::Get(Target);

        if (TTraits::StrongReference || target) {
            (target->*Method)(param$_and_$Args);
        }
    }
};
} // namespace NActionThunks

// Corresponding wrapper.
template <class TParam, class TTargetPtr, class TUnderlying$_and_$tmpl_args>
inline // TODO: FORCED_INLINE
typename IParamAction<TParam>::TPtr FromMethod(
    void (TUnderlying::* method)(TParam$_and_$TArgs) const,
    const TTargetPtr target$wrap_args)
{
    return New< NActionThunks::TParamConstMemberVoidFunc$i<TParam, TTargetPtr$_and_$TArgs> >(target, method$_and_$args);
}

////////////////////////////////////////////////////////////////////////////////
// Thunk for member function, with parameter, with return value.
namespace NActionThunks {
template <class TParam, class TResult, class TTargetPtr$_and_$tmpl_args>
class TParamMemberFunc$i
    : public IParamFunc<TParam, TResult>
{
private:
    typedef typename TActionTargetTraits<TTargetPtr>::TUnderlying TUnderlying;
    typedef TResult (TUnderlying::* TMethod)(TParam$_and_$TArgs);

$for j [[
    typedef typename TActionArgTraits<TArg$j>::TCopy TArgCopy$j;

]]

    TTargetPtr Target;
    TMethod Method;

$for j [[
    TArgCopy$j Arg$j;

]]

public:
    TParamMemberFunc$i(TTargetPtr target, TMethod method$ctor_args)
        : Target(target), Method(method)$ctor_list
    { }

    virtual TResult Do(TParam param)
    {
        TUnderlying* target = TActionTargetTraits<TTargetPtr>::Get(Target);
        return (target->*Method)(param$_and_$Args);
    }
};
} // namespace NActionThunks

// Corresponding wrapper.
template <class TParam, class TResult, class TTargetPtr, class TUnderlying$_and_$tmpl_args>
inline // TODO: FORCED_INLINE
typename IParamFunc<TParam, TResult>::TPtr FromMethod(
    TResult (TUnderlying::* method)(TParam$_and_$TArgs),
    TTargetPtr target$wrap_args)
{
    return New< NActionThunks::TParamMemberFunc$i<TParam, TResult, TTargetPtr$_and_$TArgs> >(target, method$_and_$args);
}

////////////////////////////////////////////////////////////////////////////////
// Thunk for free function, without parameter, without return value.
namespace NActionThunks {
[[$if i > 0 [[
template <$tmpl_args>

]]]]
class TVoidFunc$i
    : public IAction
{
private:
    typedef void (* TMethod)($TArgs);

$for j [[
    typedef typename TActionArgTraits<TArg$j>::TCopy TArgCopy$j;

]]

    TMethod Method;

$for j [[
    TArgCopy$j Arg$j;

]]

public:
    TVoidFunc$i(TMethod method$ctor_args)
        : Method(method)$ctor_list
    { }

    virtual void Do()
    {
        (*Method)($Args);
    }
};
} // namespace NActionThunks

// Corresponding wrapper.
[[$if i > 0 [[
template <$tmpl_args>

]]]]
inline // TODO: FORCED_INLINE
IAction::TPtr FromMethod(
    void (* method)($TArgs)$wrap_args)
{
    return New< NActionThunks::TVoidFunc$i[[$if i > 0 [[<$TArgs>]]]] >(method$_and_$args);
}

////////////////////////////////////////////////////////////////////////////////
// Thunk for free function, without parameter, with return value.
namespace NActionThunks {
template <class TResult$_and_$tmpl_args>
class TFunc$i
    : public IFunc<TResult>
{
private:
    typedef TResult (* TMethod)($TArgs);

$for j [[
    typedef typename TActionArgTraits<TArg$j>::TCopy TArgCopy$j;

]]

    TMethod Method;

$for j [[
    TArgCopy$j Arg$j;

]]

public:
    TFunc$i(TMethod method$ctor_args)
        : Method(method)$ctor_list
    { }

    virtual TResult Do()
    {
        return (*Method)($Args);
    }
};
} // namespace NActionThunks

// Corresponding wrapper.
template <class TResult$_and_$tmpl_args>
inline // TODO: FORCED_INLINE
typename IFunc<TResult>::TPtr FromMethod(
    TResult (* method)($TArgs)$wrap_args)
{
    return New< NActionThunks::TFunc$i<TResult$_and_$TArgs> >(method$_and_$args);
}

////////////////////////////////////////////////////////////////////////////////
// Thunk for free function, with parameter, without return value.
namespace NActionThunks {
template <class TParam$_and_$tmpl_args>
class TParamVoidFunc$i
    : public IParamAction<TParam>
{
private:
    typedef void (* TMethod)(TParam$_and_$TArgs);

$for j [[
    typedef typename TActionArgTraits<TArg$j>::TCopy TArgCopy$j;

]]

    TMethod Method;

$for j [[
    TArgCopy$j Arg$j;

]]

public:
    TParamVoidFunc$i(TMethod method$ctor_args)
        : Method(method)$ctor_list
    { }

    virtual void Do(TParam param)
    {
        (*Method)(param$_and_$Args);
    }
};
} // namespace NActionThunks

// Corresponding wrapper.
template <class TParam$_and_$tmpl_args>
inline // TODO: FORCED_INLINE
typename IParamAction<TParam>::TPtr FromMethod(
    void (* method)(TParam$_and_$TArgs)$wrap_args)
{
    return New< NActionThunks::TParamVoidFunc$i<TParam$_and_$TArgs> >(method$_and_$args);
}

////////////////////////////////////////////////////////////////////////////////
// Thunk for free function, with parameter, with return value.
namespace NActionThunks {
template <class TParam, class TResult$_and_$tmpl_args>
class TParamFunc$i
    : public IParamFunc<TParam, TResult>
{
private:
    typedef TResult (* TMethod)(TParam$_and_$TArgs);

$for j [[
    typedef typename TActionArgTraits<TArg$j>::TCopy TArgCopy$j;

]]

    TMethod Method;

$for j [[
    TArgCopy$j Arg$j;

]]

public:
    TParamFunc$i(TMethod method$ctor_args)
        : Method(method)$ctor_list
    { }

    virtual TResult Do(TParam param)
    {
        return (*Method)(param$_and_$Args);
    }
};
} // namespace NActionThunks

// Corresponding wrapper.
template <class TParam, class TResult$_and_$tmpl_args>
inline // TODO: FORCED_INLINE
typename IParamFunc<TParam, TResult>::TPtr FromMethod(
    TResult (* method)(TParam$_and_$TArgs)$wrap_args)
{
    return New< NActionThunks::TParamFunc$i<TParam, TResult$_and_$TArgs> >(method$_and_$args);
}


]]

////////////////////////////////////////////////////////////////////////////////

IAction::TPtr FromCallback(const TCallback<void()>& callback)
{
    return FromMethod(&TCallback<void()>::Run, &callback);
}

template <class TParam>
typename IParamAction<TParam>::TPtr FromCallback(const TCallback<void(TParam)>& callback)
{
    return FromMethod(&TCallback<void(TParam)>::Run, &callback);
}

////////////////////////////////////////////////////////////////////////////////

} // namespace NYT

/*! \endinternal */

