$$ Please, use Pump to convert this source file to valid C++ header.
$$ Note that lines in this file could be longer than 80 symbols.
#pragma once

$$ See bind.h.pump.
$var MAX_ARITY = 7
$range ARITY 0..MAX_ARITY


#ifndef CALLBACK_VIA_H_
#error "Direct inclusion of this file is not allowed, include callback.h"
#endif
#undef CALLBACK_VIA_H_

#include "invoker.h"
#include "cancelable_context.h"

namespace NYT {
/*! \internal */
////////////////////////////////////////////////////////////////////////////////

namespace NDetail {
    template <bool WrappedInFuture, class Signature>
    struct TAsyncViaHelper;
};

#ifdef __GNUC__
#define GCC_ONLY_TYPENAME typename
#else
#define GCC_ONLY_TYPENAME
#endif

$for ARITY [[
$range ARG 1..ARITY
// === Arity $(ARITY).

$if ARITY == 0 [[
template <class R>
TCallback<R()>
TCallback<R()>::Via(TIntrusivePtr<IInvoker> invoker)
]] $else [[
template <class R, $for ARG , [[class A$(ARG)]]>
TCallback<R($for ARG , [[A$(ARG)]])>
TCallback<R($for ARG , [[A$(ARG)]])>::Via(
    TIntrusivePtr<IInvoker> invoker)
]]

{
    static_assert(NMpl::TIsVoid<R>::Value,
        "Via() can be used with void return type only.");
    YASSERT(invoker);

    auto this_ = *this;
    return BIND([=] ($for ARG , [[A$(ARG) a$(ARG)]]) {
        invoker->Invoke(BIND(this_[[]]
$if ARITY != 0 [[,
            [[]]
]]
$for ARG , 
            [[ForwardRV<A$(ARG)>(a$(ARG))]]));
    });
}


$if ARITY == 0 [[
template <class R>
TCallback<R()>
TCallback<R()>::Via(
    TIntrusivePtr<IInvoker> invoker,
    TIntrusivePtr<TCancelableContext> context)
]] $else [[
template <class R, $for ARG , [[class A$(ARG)]]>
TCallback<R($for ARG , [[A$(ARG)]])>
TCallback<R($for ARG , [[A$(ARG)]])>::Via(
    TIntrusivePtr<IInvoker> invoker,
    TIntrusivePtr<TCancelableContext> context)
]]

{
    static_assert(NMpl::TIsVoid<R>::Value,
        "Via() can be used with void return type only.");
    YASSERT(invoker);
    YASSERT(context);

    auto this_ = *this;
    auto inner = BIND([=] ($for ARG , [[A$(ARG) a$(ARG)]]) {
        if (context->IsCanceled()) {
            return;
        }
        this_.Run([[]]
$if ARITY != 0 [[[[]]]]
$for ARG ,
            [[ForwardRV<A$(ARG)>(a$(ARG))]]);
    });
    auto outer = BIND([=] ($for ARG , [[A$(ARG) a$(ARG)]]) {
        if (context->IsCanceled()) {
            return;
        }
        invoker->Invoke(BIND(inner[[]]
$if ARITY != 0 [[,
            [[]]
]]
$for ARG , 
            [[ForwardRV<A$(ARG)>(a$(ARG))]]));
    });
    return outer;
}

namespace NDetail
{
template <bool W, class U[[]]
$if ARITY != 0 [[, ]]
$for ARG , [[class A$(ARG)]]>
struct TAsyncViaHelper<W, U($for ARG , [[A$(ARG)]])>
{
    typedef TCallback<U($for ARG , [[A$(ARG)]])> TSourceCallback;
    typedef TCallback<
        typename NYT::NDetail::TFutureHelper<U>::TFutureType
        ($for ARG , [[A$(ARG)]])> TTargetCallback;

    static inline TTargetCallback Do(
        const TSourceCallback& this_,
        TIntrusivePtr<IInvoker> invoker)
    {
        static_assert(!NMpl::TIsVoid<U>::Value,
            "AsyncVia() can be used with non-void callbacks only.");

        // XXX(babenko): Due to MSVC bug in lambda scope resolution
        // the following typedefs are essentially useless and we have to
        // write full type names inside lambdas.
        // XXX(sandello): Burn, MSVC!
        typedef typename NYT::NDetail::TFutureHelper<U>::TFutureType FR;
        typedef typename NYT::NDetail::TFutureHelper<U>::TPromiseType PR;

        auto inner = BIND([=] (PR promise[[]]
$if ARITY != 0 [[, ]]
$for ARG , [[A$(ARG) a$(ARG)]]) -> void {
            promise.Set(this_.Run([[]]
$if ARITY != 0 [[

                [[]]
]]
$for ARG ,
                [[ForwardRV<A$(ARG)>(a$(ARG))]]));
        });
        auto outer = BIND([=] ($for ARG , [[A$(ARG) a$(ARG)]]) -> FR {
            GCC_ONLY_TYPENAME /*PR*/
            NYT::NDetail::TFutureHelper<U>::TPromiseType promise;
            invoker->Invoke(BIND(inner, promise[[]]
$if ARITY != 0 [[,
                [[]]
]]
$for ARG , 
                [[ForwardRV<A$(ARG)>(a$(ARG))]]));
            return promise.ToFuture();
        });
        return outer;
    }
};

template <class U[[]]
$if ARITY != 0 [[, ]]
$for ARG , [[class A$(ARG)]]>
struct TAsyncViaHelper<true, U($for ARG , [[A$(ARG)]])>
{
    typedef TCallback<U($for ARG , [[A$(ARG)]])> TSourceCallback;
    typedef TCallback<
        typename NYT::NDetail::TFutureHelper<U>::TFutureType
        ($for ARG , [[A$(ARG)]])> TTargetCallback;

    static inline TTargetCallback Do(
        const TSourceCallback& this_,
        TIntrusivePtr<IInvoker> invoker)
    {
        static_assert(!NMpl::TIsVoid<U>::Value,
            "AsyncVia() can be used with non-void callbacks only.");

        // XXX(babenko): Due to MSVC bug in lambda scope resolution
        // the following typedefs are essentially useless and we have to
        // write full type names inside lambdas.
        // XXX(sandello): Burn, MSVC!
        typedef typename NYT::NDetail::TFutureHelper<U>::TValueType R;
        typedef typename NYT::NDetail::TFutureHelper<U>::TFutureType FR;
        typedef typename NYT::NDetail::TFutureHelper<U>::TPromiseType PR;

        auto promiseSetter = BIND([] (PR promise, R value) mutable {
            promise.Set(MoveRV(value));
        });
        auto inner = BIND([=] (PR promise[[]]
$if ARITY != 0 [[, ]]
$for ARG , [[A$(ARG) a$(ARG)]]) {
            this_.Run([[]]
$if ARITY != 0 [[

                [[]]
]]
$for ARG ,
                [[ForwardRV<A$(ARG)>(a$(ARG))]])
                .Subscribe(BIND(promiseSetter, promise));
        });
        auto outer = BIND([=] ($for ARG , [[A$(ARG) a$(ARG)]]) -> FR {
            GCC_ONLY_TYPENAME /*PR*/
            NYT::NDetail::TFutureHelper<U>::TPromiseType promise;
            invoker->Invoke(BIND(inner, promise[[]]
$if ARITY != 0 [[,
                [[]]
]]
$for ARG , 
                [[ForwardRV<A$(ARG)>(a$(ARG))]]));
            return promise;
        });
        return outer;
    }
};

}

$if ARITY == 0 [[
template <class U>
TCallback<typename NYT::NDetail::TFutureHelper<U>::TFutureType()>
TCallback<U()>::AsyncVia(TIntrusivePtr<IInvoker> invoker)
]] $else [[
template <class U, $for ARG , [[class A$(ARG)]]>
TCallback<
    typename NYT::NDetail::TFutureHelper<U>::TFutureType
    ($for ARG , [[A$(ARG)]])>
TCallback<U($for ARG , [[A$(ARG)]])>::AsyncVia(
    TIntrusivePtr<IInvoker> invoker)
]]

{
    return NYT::NDetail::TAsyncViaHelper<
        NYT::NDetail::TFutureHelper<U>::WrappedInFuture,
        U($for ARG , [[A$(ARG)]])
    >::Do(*this, MoveRV(invoker));
}


]] $$ for ARITY

////////////////////////////////////////////////////////////////////////////////
/*! \endinternal */
} // namespace NYT
