$$ Please, use Pump to convert this source file to valid C++ header.
$$ Note that lines in this file could be longer than 80 symbols.
#pragma once

$$ See bind.h.pump.
$var MAX_ARITY = 7
$range ARITY 0..MAX_ARITY

#ifndef CALLBACK_VIA_H_
#error "Direct inclusion of this file is not allowed, include callback.h"
#endif
#undef CALLBACK_VIA_H_

#include "invoker.h"
#include "cancelable_context.h"
#include "future.h"

namespace NYT {
/*! \internal */
////////////////////////////////////////////////////////////////////////////////

namespace NDetail {

template <bool WrappedInFuture, class TSignature>
struct TAsyncViaHelper;

} // namespace NDetail

$for ARITY [[
$range ARG 1..ARITY
// === Arity $(ARITY).

$if ARITY == 0 [[
template <class R>
TCallback<R()>
TCallback<R()>::Via(IInvokerPtr invoker)
]] $else [[
template <class R, $for ARG , [[class A$(ARG)]]>
TCallback<R($for ARG , [[A$(ARG)]])>
TCallback<R($for ARG , [[A$(ARG)]])>::Via(
    IInvokerPtr invoker)
]]

{
    static_assert(NMpl::TIsVoid<R>::Value,
        "Via() can be used with void return type only.");
    YASSERT(invoker);

    auto this_ = *this;
    return BIND([=] ($for ARG , [[A$(ARG) a$(ARG)]]) {
        invoker->Invoke(BIND(this_[[]]
$if ARITY != 0 [[,
            [[]]
]]
$for ARG , 
            [[std::forward<A$(ARG)>(a$(ARG))]]));
    });
}

$if ARITY == 0 [[
template <class R>
TCallback<R()>
TCallback<R()>::Via(
    IInvokerPtr invoker,
    TIntrusivePtr<TCancelableContext> context)
]] $else [[
template <class R, $for ARG , [[class A$(ARG)]]>
TCallback<R($for ARG , [[A$(ARG)]])>
TCallback<R($for ARG , [[A$(ARG)]])>::Via(
    IInvokerPtr invoker,
    TIntrusivePtr<TCancelableContext> context)
]]

{
    static_assert(NMpl::TIsVoid<R>::Value,
        "Via() can be used with void return type only.");
    YASSERT(invoker);
    YASSERT(context);

    auto this_ = *this;
    auto inner = BIND([=] ($for ARG , [[A$(ARG) a$(ARG)]]) {
        if (context->IsCanceled()) {
            return;
        }
        this_.Run([[]]
$if ARITY != 0 [[[[]]]]
$for ARG ,
            [[std::forward<A$(ARG)>(a$(ARG))]]);
    });
    auto outer = BIND([=] ($for ARG , [[A$(ARG) a$(ARG)]]) {
        if (context->IsCanceled()) {
            return;
        }
        invoker->Invoke(BIND(inner[[]]
$if ARITY != 0 [[,
            [[]]
]]
$for ARG , 
            [[std::forward<A$(ARG)>(a$(ARG))]]));
    });
    return outer;
}

namespace NDetail
{

template <bool W, class U[[]]
$if ARITY != 0 [[, ]]
$for ARG , [[class A$(ARG)]]>
struct TAsyncViaHelper<W, U($for ARG , [[A$(ARG)]])>
{
    typedef TCallback<U($for ARG , [[A$(ARG)]])> TSourceCallback;
    typedef TCallback<
        typename NYT::NDetail::TFutureHelper<U>::TFutureType
        ($for ARG , [[A$(ARG)]])> TTargetCallback;

    static inline TTargetCallback Do(
        const TSourceCallback& this_,
        IInvokerPtr invoker)
    {
        // XXX(babenko): Due to MSVC bug in lambda scope resolution
        // the following typedefs are essentially useless and we have to
        // write full type names inside lambdas.
        // XXX(sandello): Burn, MSVC!
        typedef typename NYT::NDetail::TFutureHelper<U>::TValueType R;
        typedef typename NYT::NDetail::TFutureHelper<U>::TFutureType FR;
        typedef typename NYT::NDetail::TFutureHelper<U>::TPromiseType PR;

        auto inner = BIND([=] (PR promise[[]]
$if ARITY != 0 [[, ]]
$for ARG , [[A$(ARG) a$(ARG)]]) -> void {
            promise.Set(this_.Run([[]]
$if ARITY != 0 [[

                [[]]
]]
$for ARG ,
                [[std::forward<A$(ARG)>(a$(ARG))]]));
        });
        auto outer = BIND([=] ($for ARG , [[A$(ARG) a$(ARG)]]) -> FR {
            auto promise = NewPromise<
                typename NYT::NDetail::TFutureHelper<U>::TValueType
            >();
            invoker->Invoke(BIND(inner, promise[[]]
$if ARITY != 0 [[,
                [[]]
]]
$for ARG , 
                [[std::forward<A$(ARG)>(a$(ARG))]]));
            return promise.ToFuture();
        });
        return outer;
    }
};

template <bool W[[]]
$if ARITY != 0 [[, ]]
$for ARG , [[class A$(ARG)]]>
struct TAsyncViaHelper<W, void($for ARG , [[A$(ARG)]])>
{
    typedef TCallback<void($for ARG , [[A$(ARG)]])> TSourceCallback;
    typedef TCallback<
        typename NYT::NDetail::TFutureHelper<void>::TFutureType
        ($for ARG , [[A$(ARG)]])> TTargetCallback;

    static inline TTargetCallback Do(
        const TSourceCallback& this_,
        IInvokerPtr invoker)
    {
        // XXX(babenko): Due to MSVC bug in lambda scope resolution
        // the following typedefs are essentially useless and we have to
        // write full type names inside lambdas.
        // XXX(sandello): Burn, MSVC!
        typedef typename NYT::NDetail::TFutureHelper<void>::TValueType R;
        typedef typename NYT::NDetail::TFutureHelper<void>::TFutureType FR;
        typedef typename NYT::NDetail::TFutureHelper<void>::TPromiseType PR;

        auto inner = BIND([=] (PR promise[[]]
$if ARITY != 0 [[, ]]
$for ARG , [[A$(ARG) a$(ARG)]]) {
            this_.Run([[]]
$if ARITY != 0 [[

                [[]]
]]
$for ARG ,
                [[std::forward<A$(ARG)>(a$(ARG))]]);
            promise.Set();
        });
        auto outer = BIND([=] ($for ARG , [[A$(ARG) a$(ARG)]]) -> FR {
            auto promise = NewPromise<
                typename NYT::NDetail::TFutureHelper<void>::TValueType
            >();
            invoker->Invoke(BIND(inner, promise[[]]
$if ARITY != 0 [[,
                [[]]
]]
$for ARG , 
                [[std::forward<A$(ARG)>(a$(ARG))]]));
            return promise.ToFuture();
        });
        return outer;
    }
};

template <class U[[]]
$if ARITY != 0 [[, ]]
$for ARG , [[class A$(ARG)]]>
struct TAsyncViaHelper<true, U($for ARG , [[A$(ARG)]])>
{
    typedef TCallback<U($for ARG , [[A$(ARG)]])> TSourceCallback;
    typedef TCallback<
        typename NYT::NDetail::TFutureHelper<U>::TFutureType
        ($for ARG , [[A$(ARG)]])> TTargetCallback;

    static inline TTargetCallback Do(
        const TSourceCallback& this_,
        IInvokerPtr invoker)
    {
        // XXX(babenko): Due to MSVC bug in lambda scope resolution
        // the following typedefs are essentially useless and we have to
        // write full type names inside lambdas.
        // XXX(sandello): Burn, MSVC!
        typedef typename NYT::NDetail::TFutureHelper<U>::TValueType R;
        typedef typename NYT::NDetail::TFutureHelper<U>::TFutureType FR;
        typedef typename NYT::NDetail::TFutureHelper<U>::TPromiseType PR;

        static auto promiseSetter = BIND(&TPromiseSetter<R>::Do);
        auto inner = BIND([=] (PR promise[[]]
$if ARITY != 0 [[, ]]
$for ARG , [[A$(ARG) a$(ARG)]]) {
            this_.Run([[]]
$if ARITY != 0 [[

                [[]]
]]
$for ARG ,
                [[std::forward<A$(ARG)>(a$(ARG))]])
                .Subscribe(BIND(promiseSetter, promise));
        });
        auto outer = BIND([=] ($for ARG , [[A$(ARG) a$(ARG)]]) -> FR {
            auto promise = NewPromise<
                typename NYT::NDetail::TFutureHelper<U>::TValueType
            >();
            invoker->Invoke(BIND(inner, promise[[]]
$if ARITY != 0 [[,
                [[]]
]]
$for ARG , 
                [[std::forward<A$(ARG)>(a$(ARG))]]));
            return promise;
        });
        return outer;
    }
};

} // namespace NDetail

$if ARITY == 0 [[
template <class U>
TCallback<typename NYT::NDetail::TFutureHelper<U>::TFutureType()>
TCallback<U()>::AsyncVia(IInvokerPtr invoker)
]] $else [[
template <class U, $for ARG , [[class A$(ARG)]]>
TCallback<
    typename NYT::NDetail::TFutureHelper<U>::TFutureType
    ($for ARG , [[A$(ARG)]])>
TCallback<U($for ARG , [[A$(ARG)]])>::AsyncVia(
    IInvokerPtr invoker)
]]

{
    return NYT::NDetail::TAsyncViaHelper<
        NYT::NDetail::TFutureHelper<U>::WrappedInFuture,
        U($for ARG , [[A$(ARG)]])
    >::Do(*this, std::move(invoker));
}

]] $$ for ARITY

////////////////////////////////////////////////////////////////////////////////
/*! \endinternal */
} // namespace NYT
