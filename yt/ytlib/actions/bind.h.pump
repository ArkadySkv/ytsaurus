$$ Please, use Pump to convert this source file to valid C++ header.
$$ Note that lines in this file could be longer than 80 symbols.
#pragma once

/*
//=============================================================================
// The following code is merely an adaptation of Chromium's
// Binds and Callbacks. Kudos to them.
//
// Original Chromium revision:
//   - git-treeish: 206a2ae8a1ebd2b040753fff7da61bbca117757f
//   - git-svn-id:  svn://svn.chromium.org/chrome/trunk/src@115607
//
// The following modifications were made while adopting the code
// to our cosy codebase.
//   - code style was adapted,
//   - reference counting semantics were altered to match YT's,
//   - rvalue-references were introduced for more efficieny.
//
// The comments are mainly by courtesy of Chromium authors.
//=============================================================================
*/

$$
$$ MAX_ARITY controls the number of arguments that Bind() supports.
$$ The amount of code, and more importantly, the number of template types
$$ generated by pump grows at O(MAX_ARITY^2).
$$
$$ We tried going to 11 and found it imposed an extra 10 penalty on windows
$$ cycle times compared to our original baseline of 6.
$$
$$ Currently 7 is chosen as a compromise between supporting a convenient
$$ number of arguments and keeping compile times low.  At 7, we have 115
$$ templates being generated by pump.
$$
$$ Be careful when adjusting this number.  If people find a need to bind
$$ a larger number of arguments, consider refactoring the function to use
$$ a param struct instead of raising the MAX_ARITY.
$$
$$ See http://crbug.com/98542 for more context.
$$

$var MAX_ARITY = 7

#include "bind_internal.h"
#include "callback_internal.h"

namespace NYT {
/*! \internal */
////////////////////////////////////////////////////////////////////////////////
//
// See "callback.h" for how to use these functions. If reading
// the implementation, before proceeding further, you should read the top
// comment of "bind_internal.h" for a definition of common terms and concepts.
//
// IMPLEMENTATION NOTE
//
// Though #Bind()'s result is meant to be stored in a #TCallback<> type, it
// cannot actually return the exact type without requiring a large amount
// of extra template specializations. The problem is that in order to
// discern the correct specialization of #TCallback<>, #Bind() would need to
// unwrap the function signature to determine the signature's arity, and
// whether or not it is a method.
//
// Each unique combination of (arity, function_type, num_prebound) where
// |function_type| is one of {function, method, const_method} would require
// one specialization. We eventually have to do a similar number of
// specializations anyways in the implementation (see the #TInvoker<>,
// classes). However, it is avoidable in #Bind() if we return the result
// via an indirection like we do below.
//
// It is possible to move most of the compile time asserts into TBindState<>,
// but it feels a little nicer to have the asserts here so people do not
// need to crack open "bind_internal.h". On the other hand, it makes #Bind()
// harder to read.
//

$range ARITY 0..MAX_ARITY
$for ARITY [[
$range ARG 1..ARITY

template <typename Functor[[]]
$if ARITY > 0 [[, ]] $for ARG , [[typename P$(ARG)]]>
TCallback<
    typename NDetail::TBindState<
        typename NDetail::TFunctorTraits<Functor>::TRunnableType,
        typename NDetail::TFunctorTraits<Functor>::Signature,
        void($for ARG , [[typename NMpl::TDecay<P$(ARG)>::TType]])
    >::UnboundSignature>
Bind(Functor functor
$if ARITY > 0 [[, ]] $for ARG , [[P$(ARG)&& p$(ARG)]]) {
    // Typedefs for how to store and run the functor.
    typedef NDetail::TFunctorTraits<Functor> TFunctorTraits;
    typedef typename TFunctorTraits::TRunnableType TRunnableType;
    typedef typename TFunctorTraits::Signature Signature;

    // Use TRunnableType::Signature instead of Signature above because our
    // checks should below for bound references need to know what the actual
    // functor is going to interpret the argument as.
    typedef NDetail::TFunctionTraits<typename TRunnableType::Signature>
        TBoundFunctionTraits;

$if ARITY > 0 [[

    // Do not allow binding a non-const reference parameter. Binding a
    // non-const reference parameter can make for subtle bugs because the
    // invoked function will receive a reference to the stored copy of the
    // argument and not the original.
    static_assert(
        !($for ARG || [[NDetail::TIsNonConstReference<typename TBoundFunctionTraits::A$(ARG)Type>::Value]]),
        "Do not bind non-const references.");

]]


$for ARG [[


$if ARG == 1 [[
    // For methods, we need to be careful for parameter 1. We do not require
    // a #TIntrusivePtr<> because #TBindState<> itself takes care of Ref() for
    // methods. We also disallow binding of an array as the method's target
    // object.
    static_assert(
        NDetail::TIsMethodHelper<TRunnableType>::Value ||
        !NDetail::TExpectedIntrusivePtrAndActualRawPtrHelper<P$(ARG)>::Value,
        "p$(ARG) has reference-counted type and should not be bound \
by the raw pointer");
    static_assert(!(
        NDetail::TIsMethodHelper<TRunnableType>::Value &&
        NMpl::TIsArray<P$(ARG)>::Value),
        "First bound argument to a method cannot be an array");
]] $else [[
    static_assert(
        !NDetail::TExpectedIntrusivePtrAndActualRawPtrHelper<P$(ARG)>::Value,
        "p$(ARG) has reference-counted type and should not be bound \
by the raw pointer");
]]  $$ $if ARG

]]  $$ $for ARG

    typedef NDetail::TBindState<TRunnableType, Signature, [[]]
void($for ARG , [[typename NMpl::TDecay<P$(ARG)>::TType]])> [[]]
TBindState;


    return TCallback<typename TBindState::UnboundSignature>(
        New<TBindState>(NDetail::MakeRunnable(functor)[[]]
$if ARITY > 0 [[, ]] $for ARG , [[ForwardRV<P$(ARG)>(p$(ARG))]]));
}

]]  $$ for ARITY

////////////////////////////////////////////////////////////////////////////////
/*! \endinternal */    
} // namespace NYT
