package NYT.NTableClient.NProto;

import "yt/ytlib/table_client/table_chunk_meta.proto";
import "yt/ytlib/misc/guid.proto";
import "yt/ytlib/misc/extensions.proto";

////////////////////////////////////////////////////////////////////////////////

// A read boundary given either by a row index, or a key, or both.
// The boundary is inclusive or exclusive depending of the context (see TChunkSlice below).
message TReadLimit
{
    optional int64 row_index = 1;
    optional TKey key = 2;
}

// A contiguous part of a single table chunk.
message TChunkSlice
{
    // The id of the chunk.
    required NYT.NProto.TGuid chunk_id = 1;
    // The left boundary, inclusive.
    required TReadLimit start_limit = 2;
    // The right boundary, exclusive.
    required TReadLimit end_limit = 3;
}

// Describes a portion of table chunk.
message TInputChunk
{
    // A part of table chunk.
    required TChunkSlice slice = 1;

    // Initial seed addresses. The reader may ask the master for additional ones.
    repeated string node_addresses = 2;

    // Column filter.
    required TChannel channel = 3;

    required NYT.NProto.TExtensionSet extensions = 4;

    // When this value is given the reader inserts this YSON map as attributes at every row.
    // This enables,  e.g., the client to distinguish between several tables coming through a single input stream.
    optional bytes row_attributes = 5 [default = ""];

    // Sometimes the party constructing an instance of TInputChunk has
    // a much more precise information about the data size and the row count.
    // A typical example is the scheduler preparing the input for a sort job.
    // Here's the place for such overrides.
    required int64 data_weight = 6;
    required int64 row_count = 7;

    optional int32 partition_tag = 8 [default = -1];
}

////////////////////////////////////////////////////////////////////////////////
