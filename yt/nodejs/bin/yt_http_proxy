#!/usr/bin/env node

// Standard modules.
var cluster = require("cluster");
var fs = require("fs");
var net = require("net");

// NPM modules.
var optimist = require("optimist");
var uid_number = require("uid-number");
var winstond = require("winstond");

var Q = require("q");

// Program arguments.
var opts = optimist
    .usage("Provide HTTP API for YT.\nUsage: $0")

    .alias("c", "config")
    .describe("c", "Specify configuration file")

    .alias("p", "port")
    .describe("p", "Specify port to listen")

    .alias("a", "address")
    .describe("a", "Specify address to listen")

    .alias("n", "number-of-workers")
    .describe("n", "Specify number of worker processes")

    .alias("m", "memory-limit")
    .describe("m", "Specify memory limit (in MB) for data buffer size for each request")

    .alias("t", "thread-limit")
    .describe("t", "Specify thread limit for concurrent off-loop processing")

    .alias("s", "spare-threads")
    .describe("s", "Specify a number of threads reserved for non-heavy tasks")

    .alias("l", "log")
    .describe("l", "Specify log file")

    .alias("u", "user")
    .describe("u", "Specify a user to setuid() to")

    .alias("g", "group")
    .describe("g", "Specify a group to setgid() to")

    .alias("v", "version")
    .boolean("v")
    .describe("v", "Show version and exit")

    .alias("h", "help")
    .boolean("h")
    .describe("h", "Show help message and exit")

    .string("user_interface")
    .describe("user_interface", "Path to the UI")
    .default("user_interface", "/usr/share/yt")

    .boolean("read_only")
    .describe("read_only", "Enable read-only mode")
    .default("read_only", false)

    .boolean("profiler")
    .describe("profiler", "Enable V8 profiler")
    .default("profiler", false)
    ;

////////////////////////////////////////////////////////////////////////////////

var agent;
var profiler;
var config;
var version;

try {
    version = JSON.parse(fs.readFileSync(__dirname + "/../package.json"));
} catch (ex) {
    version = { version : "(development)", dependencies : {} };
}

if (opts.argv.v) {
    console.error("*** YT HTTP Proxy ***");
    console.error("Version %s", version.version);
    for (var p in version.dependencies) {
        if (version.dependencies.hasOwnProperty(p)) {
            console.error("Depends on %s (%s)", p, version.dependencies[p]);
        }
    }
    process.exit(0);
}

if (opts.argv.h) {
    opts.showHelp();
    process.exit(0);
}

////////////////////////////////////////////////////////////////////////////////

function merge(lhs, rhs) {
    for (var p in rhs) {
        try {
            if (typeof(rhs[p]) !== "undefined" && rhs[p] !== null) {
                if (rhs[p].constructor === Object) {
                    lhs[p] = merge(lhs[p], rhs[p]);
                } else {
                    lhs[p] = rhs[p];
                }
            }
        } catch(err) {
            lhs[p] = rhs[p];
        }
    }
    return lhs;
}

config = {
    port              : 80,
    log_port          : 59999,
    address           : "::",
    log_address       : "::1",
    neighbours        : [ "::1" ],
    number_of_workers : 4,
    memory_limit      : 32 * 1024 * 1024,
    thread_limit      : 32,
    spare_threads     : 4,
    user_interface    : opts.argv.user_interface,
    read_only         : opts.argv.read_only,
    profiler          : opts.argv.profiler,
    proxy             : { logging : { rules : [], writers : {} } },
    locals            : {},
    oauth : {
        host: "oauth.yandex-team.ru",
        port: 80,
        authorize_path: "/authorize",
        token_path: "/token",
        timeout: 3000,
        applications: [
            {
                key: "api",
                client_id: "7dc2b061bd884693b520730cfb61b011",
                client_secret: "c494ca8a946a40f9bbdb36615b14551f"
            },
            {
                key: "ui",
                client_id: "d3aa642b20bf42e6a85cb8b62ddb25ed",
                client_secret: "93008f89679c46b6a79fad9ebd776879"
            }
        ]
    },
    blackbox: {
        host: "blackbox.yandex-team.ru",
        port: 80,
        path: "/blackbox",
        timeout: 3000,
        retries: 5
    }
};

config = merge(config, (opts.argv.c && JSON.parse(fs.readFileSync(opts.argv.c, "utf8"))) || {});
config = merge(config, {
    port              : opts.argv.p && parseInt(opts.argv.p),
    address           : opts.argv.a,
    number_of_workers : opts.argv.n && parseInt(opts.argv.n),
    memory_limit      : opts.argv.m && parseInt(opts.argv.m) * 1024 * 1024,
    thread_limit      : opts.argv.t && parseInt(opts.argv.t),
    spare_threads     : opts.argv.s && parseInt(opts.argv.s),
    logging           : opts.argv.l && { filename : opts.argv.l, timestamp : true, raw : true },
    user              : opts.argv.u,
    group             : opts.argv.g
});

////////////////////////////////////////////////////////////////////////////////

if (config.profiler) {
    var agent = require("webkit-devtools-agent");
    var profiler = require("v8-profiler");
}

////////////////////////////////////////////////////////////////////////////////

function ensureFileExistsAndOwned(path, user, group) {
    return Q
        .ncall(fs.exists, fs, path)
        .fail(function(exists) {
            return exists || Q
                .ncall(fs.writeFile, fs, path, "")
                .then(Q
                    .ncall(uid_number, undefined, user || process.getuid(), group || process.getgid)
                    .spread(Q.nbind(fs.chown, path))
                );
        });
};

function provideWinstonTransport() {
    if (config.logging) {
        return Q.when(
            ensureFileExistsAndOwned(config.logging.filename, config.user, config.group),
            function() {
                console.error("Setting up logging to file '%s'", config.logging.filename);
                return new winstond.transports.File(config.logging);
            });
    } else {
        return Q.fcall(function() {
            console.error("Setting up logging to console");
            return new winstond.transports.Console({ timestamp : true, raw : false, colorize : true });
        });
    }
}

function provideWinstonLogger(transport) {
    console.error("Winston is listening on address '%s' on port '%s'", config.log_address, config.log_port);
    var server = winstond.nssocket.createServer({
        host : config.log_address,
        port : config.log_port,
        services : [ "collect" ],
        transports : [ transport ]
    });
    server.listen();
    return server;
}

function createLogger() {
    return Q.fcall(provideWinstonTransport).then(provideWinstonLogger);
}

function runProxy(logger) {
    process.env.YT_PROXY_CONFIGURATION = JSON.stringify(config);
    process.env.YT_PROXY_VERSION = JSON.stringify(version);
    process.env.YT_PROXY_MASTER = process.pid.toString();

    var master = new (require(__dirname + "/../lib/master.js").that)(
        logger, config.number_of_workers, {
            exec : __dirname + "/../lib/worker.js",
            args : []
    });

    logger.error("Starting HTTP proxy master", { pid : process.pid });

    var fake_server = net.createServer();
    fake_server.listen(config.port, config.address, function() {
        fake_server.close(function() {
            master.kickstart();
        });
    });

    var cc1 = new Date(),
        cc2 = new Date(),
        cc3 = new Date();

    process.on("SIGINT", function() {
        cc3 = cc2; cc2 = cc1; cc1 = new Date();
        var n = ((cc1 - cc2) < 1000 ? 1 : 0) +
                ((cc1 - cc3) < 1000 ? 1 : 0);
        switch (n) {
            case 0:
                master.restartWorkers();
                break;
            case 1:
                master.shutdownWorkers();
                break;
            case 2:
                process.exit(0);
                break;
        }
    });

    process.on("SIGUSR1", master.debug.bind(master));
    process.on("SIGUSR2", master.restartWorkers.bind(master));

    // process.on("SIGTERM", master.shutdownWorkers.bind(master));
    // process.on("SIGKILL", master.shutdownWorkers.bind(master));
}

////////////////////////////////////////////////////////////////////////////////

// Magic line.
Q.all([ createLogger() ]).spread(runProxy).end();
