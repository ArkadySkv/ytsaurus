$$ Please, use Pump to convert this source file to valid C++ header.
$$ Note that lines in this file could be longer than 80 symbols.
#pragma once

/*
//=============================================================================
// The following code is merely an adaptation of Chromium's
// Binds and Callbacks. Kudos to them.
//
// Original Chromium revision:
//   - git-treeish: 206a2ae8a1ebd2b040753fff7da61bbca117757f
//   - git-svn-id:  svn://svn.chromium.org/chrome/trunk/src@115607
//
// The following modifications were made while adopting the code
// to our cosy codebase.
//   - code style was adapted,
//   - reference counting semantics were altered to match YT's,
//   - rvalue-references were introduced for more efficieny.
//
// The comments are mainly by courtesy of Chromium authors.
//=============================================================================
*/

$$
$$ MAX_ARITY controls the number of arguments that Bind() supports.
$$ The amount of code, and more importantly, the number of template types
$$ generated by pump grows at O(MAX_ARITY^2).
$$
$$ We tried going to 11 and found it imposed an extra 10 penalty on windows
$$ cycle times compared to our original baseline of 6.
$$
$$ Currently 7 is chosen as a compromise between supporting a convenient
$$ number of arguments and keeping compile times low.  At 7, we have 115
$$ templates being generated by pump.
$$
$$ Be careful when adjusting this number.  If people find a need to bind
$$ a larger number of arguments, consider refactoring the function to use
$$ a param struct instead of raising the MAX_ARITY.
$$
$$ See http://crbug.com/98542 for more context.
$$

$var MAX_ARITY = 7
$range ARITY 0..MAX_ARITY

#include "bind_internal.h"
#include "callback_internal.h"

#ifdef ENABLE_BIND_LOCATION_TRACKING
#define BIND(...) ::NYT::Bind(FROM_HERE, __VA_ARGS__)
#else
#define BIND(...) ::NYT::Bind(__VA_ARGS__)
#endif

namespace NYT {
/*! \internal */
////////////////////////////////////////////////////////////////////////////////
//
// See "callback.h" for how to use these functions. If reading
// the implementation, before proceeding further, you should read the top
// comment of "bind_internal.h" for a definition of common terms and concepts.
//
// IMPLEMENTATION NOTE
//
// Though #Bind()'s result is meant to be stored in a #TCallback<> type, it
// cannot actually return the exact type without requiring a large amount
// of extra template specializations. The problem is that in order to
// discern the correct specialization of #TCallback<>, #Bind() would need to
// unwrap the function signature to determine the signature's arity, and
// whether or not it is a method.
//
// Each unique combination of (arity, function_type, num_prebound) where
// |function_type| is one of {function, method, const_method} would require
// one specialization. We eventually have to do a similar number of
// specializations anyways in the implementation (see the #TInvoker<>,
// classes). However, it is avoidable in #Bind() if we return the result
// via an indirection like we do below.
//
// It is possible to move most of the compile time asserts into #TBindState<>,
// but it feels a little nicer to have the asserts here so people do not
// need to crack open "bind_internal.h". On the other hand, it makes #Bind()
// harder to read.
//

$for ARITY [[
$range ARG 1..ARITY

template <class Functor[[]]
$if ARITY > 0 [[, ]] $for ARG , [[class P$(ARG)]]>
TCallback<
    typename NYT::NDetail::TBindState<
        typename NYT::NDetail::TFunctorTraits<Functor>::TRunnableType,
        typename NYT::NDetail::TFunctorTraits<Functor>::Signature,
        void($for ARG , [[typename NMpl::TDecay<P$(ARG)>::TType]])
    >::UnboundSignature>
Bind(
#ifdef ENABLE_BIND_LOCATION_TRACKING
    const TSourceLocation& location,
#endif
    Functor functor[[]]
$if ARITY > 0 [[, ]] $for ARG , [[P$(ARG)&& p$(ARG)]]) {

    // Typedefs for how to store and run the functor.
    typedef NYT::NDetail::TFunctorTraits<Functor> TFunctorTraits;
    typedef typename TFunctorTraits::TRunnableType TRunnableType;
    typedef typename TFunctorTraits::Signature Signature;

    // Use TRunnableType::Signature instead of Signature above because our
    // checks should below for bound references need to know what the actual
    // functor is going to interpret the argument as.
    typedef NYT::NDetail::TSignatureTraits<typename TRunnableType::Signature>
        TBoundSignatureTraits;

$if ARITY > 0 [[

    // Do not allow binding a non-const reference parameter. Binding a
    // non-const reference parameter can make for subtle bugs because the
    // invoked function will receive a reference to the stored copy of the
    // argument and not the original.
    //
    // Do not allow binding a raw pointer parameter for a reference-counted type.
    // Binding a raw pointer can result in invocation with dead parameters,
    // because #TBindState do not hold references to parameters.

]]  $$ if ARITY > 0


$for ARG [[
$if ARG == 1 [[
    static_assert(!(
        NYT::NDetail::TIsMethodHelper<TRunnableType>::Value &&
        NMpl::TIsArray<P$(ARG)>::Value),
        "First bound argument to a method cannot be an array");

]]  $$ $if ARG

    static_assert(
        !NYT::NDetail::TIsNonConstReference<typename TBoundSignatureTraits::A$(ARG)Type>::Value,
        "p$(ARG) is a non-const reference and should not be bound.");
    static_assert(
        !NYT::NDetail::TRawPtrToRefCountedTypeHelper<P$(ARG)>::Value,
        "p$(ARG) has reference-counted type and should not be bound \
by the raw pointer");

]]  $$ $for ARG

    typedef NYT::NDetail::TBindState<TRunnableType, Signature, [[]]
void($for ARG , [[typename NMpl::TDecay<P$(ARG)>::TType]])> [[]]
TTypedBindState;
    return TCallback<typename TTypedBindState::UnboundSignature>(
        New<TTypedBindState>(
#ifdef ENABLE_BIND_LOCATION_TRACKING
            location,
#endif
            NYT::NDetail::MakeRunnable(functor)
$if ARITY > 0 [[, ]] $for ARG , [[std::forward<P$(ARG)>(p$(ARG))]]));
}

]]  $$ for ARITY

////////////////////////////////////////////////////////////////////////////////
/*! \endinternal */    
} // namespace NYT
