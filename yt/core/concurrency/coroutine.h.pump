$$ Please, use Pump to convert this source file to valid C++ header.
$$ Note that lines in this file could be longer than 80 symbols.
#pragma once

$var MAX_ARITY = 7
$range ARITY 0..MAX_ARITY

#include "public.h"
#include "fiber.h"

#include <core/misc/nullable.h>

namespace NYT {
namespace NConcurrency {

////////////////////////////////////////////////////////////////////////////////

template <class Signature>
class TCoroutine;

class TCoroutineBase
{
protected:
    TCoroutineBase();
    virtual ~TCoroutineBase();

    virtual void Trampoline() = 0;

public:
    EFiberState GetState() const;

protected:
    TFiberPtr Fiber;

private:
    TCoroutineBase(const TCoroutineBase&);
    TCoroutineBase& operator=(const TCoroutineBase&);

};

$for ARITY [[
$range ARG 1..ARITY

////////////////////////////////////////////////////////////////////////////////
// === Arity $(ARITY), non-void result type.

template <class R[[]]
$if ARITY > 0[[, ]] $for ARG , [[class A$(ARG)]]>
class TCoroutine<R($for ARG , [[A$(ARG)]])>
    : public TCoroutineBase
{
public:
    typedef R (FunctionalSignature)($for ARG , [[A$(ARG)]]);
    typedef void (CoroutineSignature)(TCoroutine&[[]]
$if ARITY > 0 [[, ]] $for ARG , [[A$(ARG)]]);

    typedef TCallback<CoroutineSignature> TCallee;
$if ARITY > 0 [[

    typedef std::tuple<$for ARG , [[A$(ARG)]]> TArguments;
]]


    TCoroutine()
        : TCoroutineBase()
    { }

    TCoroutine(TCallee&& callee)
        : TCoroutineBase()
        , Callee(std::move(callee))
    { }

    void Reset(TCallee callee)
    {
        Fiber->Reset();
        Callee = std::move(callee);
    }


$if ARITY > 0 [[
    template <$for ARG , [[class P$(ARG)]]>

]]
[[    ]]const TNullable<R>& Run($for ARG , [[P$(ARG)&& p$(ARG)]])
    {
$if ARITY > 0 [[

        Arguments = std::make_tuple([[]]
$for ARG , [[std::forward<P$(ARG)>(p$(ARG))]]);
]]

        Fiber->Run();
        return Result;
    }

    template <class Q>
    $if ARITY > 0 [[TArguments&&]] $else [[void]] Yield(Q&& result)
    {
        Result = std::forward<Q>(result);
        Fiber->Yield();
        return[[]]$if ARITY > 0 [[ std::move(Arguments)]];
    }

private:
    virtual void Trampoline() override
    {
        try {
            Callee.Run(*this[[]]
$if ARITY > 0 [[, ]]
$for ARG , [[std::get<$(ARG - 1)>(std::move(Arguments))]]);
            Result.Reset();
        } catch(...) {
            Result.Reset();
            throw;
        }
    }

private:
    TCallee Callee;
$if ARITY > 0 [[

    TArguments Arguments;
]]

    TNullable<R> Result;
};

////////////////////////////////////////////////////////////////////////////////
// === Arity $(ARITY), void result type.

template <$for ARG , [[class A$(ARG)]]>
class TCoroutine<void($for ARG , [[A$(ARG)]])>
    : public TCoroutineBase
{
public:
    typedef void (FunctionalSignature)($for ARG , [[A$(ARG)]]);
    typedef void (CoroutineSignature)(TCoroutine&[[]]
$if ARITY > 0 [[, ]] $for ARG , [[A$(ARG)]]);

    typedef TCallback<CoroutineSignature> TCallee;
$if ARITY > 0 [[

    typedef std::tuple<$for ARG , [[A$(ARG)]]> TArguments;
]]


    TCoroutine()
        : TCoroutineBase()
    { }

    TCoroutine(TCallee&& callee)
        : TCoroutineBase()
        , Callee(std::move(callee))
    { }

    void Reset(TCallee callee)
    {
        Fiber->Reset();
        Callee = std::move(callee);
    }


$if ARITY > 0 [[
    template <$for ARG , [[class P$(ARG)]]>

]]
[[    ]]bool Run($for ARG , [[P$(ARG)&& p$(ARG)]])
    {
$if ARITY > 0 [[

        Arguments = std::make_tuple([[]]
$for ARG , [[std::forward<P$(ARG)>(p$(ARG))]]);
]]

        Fiber->Run();
        return Result;
    }

    $if ARITY > 0 [[TArguments&&]] $else [[void]] Yield()
    {
        Result = true;
        Fiber->Yield();
        return[[]]$if ARITY > 0 [[ std::move(Arguments)]];
    }

private:
    virtual void Trampoline() override
    {
        try {
            Callee.Run(*this[[]]
$if ARITY > 0 [[, ]]
$for ARG , [[std::get<$(ARG - 1)>(std::move(Arguments))]]);
            Result = false;
        } catch(const std::exception& ex) {
            Result = false;
            throw;
        }
    }

private:
    TCallee Callee;
$if ARITY > 0 [[

    TArguments Arguments;
]]

    bool Result;
};


]]

////////////////////////////////////////////////////////////////////////////////

} // namespace NConcurrency
} // namespace NYT
